<!DOCTYPE HTML>

<html>
<head>
    <link href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.6/css/bootstrap.min.css" rel="stylesheet" integrity="sha384-1q8mTJOASx8j1Au+a5WDVnPi2lkFfwwEAa8hDDdjZlpLegxhjVME1fgjWPGmkzs7" crossorigin="anonymous">   
    <script src="https://code.jquery.com/jquery-2.2.4.min.js"></script>
    <script type="text/javascript" src="../../dist/charls-js.js"></script>
</head>
<body>
<div class="container">
    <div class="page-header">
        <h1>JPEG-LS Decoding with WASM</h1>
        <p class="lead">
          Select an image or drag and drop a JPEG-LS file
      </p>
    </div>

    <div class="row">
      <select id="imageSelector">
        <option value="../../test/fixtures/CT1.JLS" selected>CT1</option>
        <option value="../../test/fixtures/CT2.JLS">CT2</option>
        <option value="../../test/fixtures/MG1.JLS">MG1</option>
        <option value="../../extern/charls/test/conformance/T8C0E0.JLS">T8C0E0</option>
        <option value="../../extern/charls/test/conformance/T8C0E3.JLS">T8C0E3</option>
        <option value="../../extern/charls/test/conformance/T8C1E0.JLS">T8C1E0</option>
        <option value="../../extern/charls/test/conformance/T8C1E3.JLS">T8C1E3</option>
        <option value="../../extern/charls/test/conformance/T8C2E0.JLS">T8C2E0</option>
        <option value="../../extern/charls/test/conformance/T8C2E3.JLS">T8C2E3</option>
        <option value="../../extern/charls/test/conformance/T8NDE3.JLS">T8NDE3</option>
        <option value="../../extern/charls/test/conformance/T8SSE0.JLS">T8SSE0 - not working</option>
        <option value="../../extern/charls/test/conformance/T8SSE3.JLS">T8SSE3 - not working</option>
        <option value="../../extern/charls/test/conformance/T16E0.JLS">T16E0</option>
        <option value="../../extern/charls/test/conformance/T16E3.JLS">T16E3</option>
        <option value="../../extern/charls/test/lena8b.jls">lena8b</option>
        <option value="../../extern/charls/test/mr2_unc.jls">mr2_unc - not working</option>
        <option value="../../extern/charls/test/jlsimage/banny_HP1.jls">banny_HP1</option>
        <option value="../../extern/charls/test/jlsimage/banny_HP2.jls">banny_HP2</option>
        <option value="../../extern/charls/test/jlsimage/banny_HP3.jls">banny_HP3</option>
        <option value="../../extern/charls/test/jlsimage/banny_normal.jls">banny_normal</option>
      </select>
      <br>
      <span>Status: </span><span id="status"></span>
      <br>
      <span>Encoded Size: </span><span id="encodedSize"></span>
      <br>
      <span>Copy to WASM Time: </span><span id="copytoWASMTime"></span>
      <br>
      <span>Decode Time: </span><span id="decodeTime"></span>
      <br>
      <span>Display Time: </span><span id="displayTime"></span>
      <br>
      <span>Width: </span><span id="width"></span>
      <br>
      <span>Height: </span><span id="height"></span>
      <br>
      <span>Bits Per Sample: </span><span id="bitsPerSample"></span>
      <br>
      <span>Component Count: </span><span id="componentCount"></span>
      <br>
      <span>Interleave Mode: </span><span id="interleaveMode"></span>
      <br>
      <span>Near Lossless: </span><span id="nearLossless"></span>
    </div>


  <div class="row">
    <div class="col-md-6">
        <canvas id='myCanvas' width="512" height="512"/>
    </div>
  </div>
</body>

<script>
  function getMinMax(frameInfo, pixelData) {
    const numPixels = frameInfo.width * frameInfo.height * frameInfo.componentCount;
    let min = pixelData[0];
    let max = pixelData[0];
    for(let i=0; i < numPixels; i++) {
      if(pixelData[i] < min) {
        min = pixelData[i];
      }
      if(pixelData[i] > max) {
        max = pixelData[i];
      }
    }
    return {min, max};
  }

  function getPixelData(frameInfo, decodedBuffer) {
    if(frameInfo.bitsPerSample > 8) {
      //return decodedBuffer;
      return new Uint16Array(decodedBuffer.buffer, decodedBuffer.byteOffset, decodedBuffer.byteLength);
    } else {
      return decodedBuffer;
    }
  }

  function display(frameInfo, decodedBuffer, interleaveMode) {
    const pixelData = getPixelData(frameInfo, decodedBuffer);

    const begin = performance.now(); // performance.now() returns value in milliseconds
    var c = document.getElementById("myCanvas");
    var ctx = c.getContext("2d");
    ctx.fillRect(0,0,c.width, c.height);

    c.width = frameInfo.width;
    c.height = frameInfo.height;
    ctx.fillStyle = "#000000";
    ctx.fillRect(0,0,frameInfo.width, frameInfo.height);
    var myImageData = ctx.createImageData(frameInfo.width, frameInfo.height);
    var outOffset = 0;
    var planeSize = frameInfo.width * frameInfo.height;
    var inOffset = 0;
   
    const minMax = getMinMax(frameInfo, pixelData);
    for(var y=0; y < frameInfo.height; y++) {
      for (var x = 0; x < frameInfo.width; x++) {
        if(frameInfo.bitsPerSample <= 8) {
          if (frameInfo.componentCount === 1) {
              myImageData.data[outOffset + 3] = pixelData[inOffset++];
              outOffset += 4;
          } else if (frameInfo.componentCount === 3) {
            if (interleaveMode === 0) { // none (I think this is supposed to be planar but it doesn't work)
                myImageData.data[outOffset++] = pixelData[inOffset++];
                myImageData.data[outOffset++] = pixelData[inOffset + planeSize];
                myImageData.data[outOffset++] = pixelData[inOffset + (planeSize * 2)];
                myImageData.data[outOffset++] = 255;
                inOffset++;
            }
            else if (interleaveMode === 1) { // line (actually RGB)
                myImageData.data[outOffset++] = pixelData[inOffset++];
                myImageData.data[outOffset++] = pixelData[inOffset++];
                myImageData.data[outOffset++] = pixelData[inOffset++];
                myImageData.data[outOffset++] = 255;
            }
            else if (interleaveMode === 2) { // pixel/sample (actually RGB)
                myImageData.data[outOffset++] = pixelData[inOffset++];
                myImageData.data[outOffset++] = pixelData[inOffset++];
                myImageData.data[outOffset++] = pixelData[inOffset++];
                myImageData.data[outOffset++] = 255;
            }
          }
        } 
        else // bitsPerSample > 8 
        {
          //pixelData[inOffset] = x;
          const fullPixel = pixelData[inOffset++];
          const value = (fullPixel >> 4) & 255;
          myImageData.data[outOffset + 3] = value;
          outOffset += 4;
        }
      }
    }
    ctx.putImageData(myImageData, 0, 0);
    const end = performance.now();
    $('#displayTime').text(end-begin + ' ms');
  }

  function decode(encodedJPEGLSBitStream) {
    $('#encodedSize').text('' + encodedJPEGLSBitStream.length.toLocaleString() + ' bytes');

    // Setup
    let instance = new Module.JpegLSDecode(encodedJPEGLSBitStream.length);
    const encodedBuffer = instance.getEncodedBuffer();
    let begin = performance.now(); // performance.now() returns value in milliseconds
    encodedBuffer.set(encodedJPEGLSBitStream);
    let end = performance.now();
    $('#copytoWASMTime').text(end-begin + ' ms');

    // Decode
    begin = performance.now(); // performance.now() returns value in milliseconds
    instance.decode();
    end = performance.now();
    $('#decodeTime').text(end-begin + ' ms');

    const frameInfo = instance.getFrameInfo();
    const interleaveMode = instance.getInterleaveMode();
    const nearLossless = instance.getNearLossless();

    // Display image properties
    $('#width').text(''+frameInfo.width);
    $('#height').text(''+frameInfo.height);
    $('#bitsPerSample').text(''+frameInfo.bitsPerSample);
    $('#componentCount').text(''+frameInfo.componentCount);
    $('#interleaveMode').text(''+interleaveMode);
    $('#nearLossless').text(''+nearLossless);

    // Display Image
    var decodedBuffer = instance.getDecodedBuffer();
    display(frameInfo, decodedBuffer, interleaveMode);

    // Free up memory
    instance.delete();
  }

  function load(url) {
    fetch(url)
    .then((response) => {
      return response.arrayBuffer();
    })
    .then((arrayBuffer) => {
      decode(new Uint8Array(arrayBuffer));
    }).catch(function() {
      $('#status').text('error loading ' + url);
    });
  }

  function reset() {
    const c = document.getElementById("myCanvas");
    const ctx = c.getContext("2d");
    ctx.fillRect(0,0,c.width, c.height);
    $('#status').text('');
    $('#encodedSize').text('');
    $('#copytoWASMTime').text('');
    $('#decodeTime').text('');
    $('#displayTime').text('');
    $('#width').text('');
    $('#height').text('');
    $('#bitsPerSample').text('');
    $('#componentCount').text('');
    $('#interleaveMode').text('');
    $('#nearLossless').text('');
  }

  Module.onRuntimeInitialized = async _ => {
    load('../../test/fixtures/CT1.JLS');

    $('#imageSelector').change(function(e) {
      reset();
      load(e.target.options[e.target.selectedIndex].value);
    });

    // this function gets called once the user drops the file onto the div
    function handleFileSelect(evt) {
      evt.stopPropagation();
      evt.preventDefault();

      // Get the FileList object that contains the list of files that were dropped
      var files = evt.dataTransfer.files;

      // this UI is only built for a single file so just dump the first one
      var file = files[0];

      var fileReader = new FileReader();
      fileReader.onload = function (e) {
          var fileAsArrayBuffer = e.target.result;
          var byteArray = new Uint8Array(fileAsArrayBuffer);
          decode(byteArray);
      };
      fileReader.readAsArrayBuffer(file);
    }

    function handleDragOver(evt) {
        evt.stopPropagation();
        evt.preventDefault();
        evt.dataTransfer.dropEffect = 'copy'; // Explicitly show this is a copy.
    }

    // Setup the dnd listeners.
    var dropZone = document.getElementById('myCanvas');
    dropZone.addEventListener('dragover', handleDragOver, false);
    dropZone.addEventListener('drop', handleFileSelect, false);

  }
</script>
</html>
